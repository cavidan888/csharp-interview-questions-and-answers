# C# Müsahibə sualları və cavabları
## Araşdırma qaynaqları 
 - https://www.commonlounge.com/
 - https://www.quora.com/
 - https://www.freecodecamp.org/

1. C# nədir? (Cavidan)

> C# 2000 - ci ildə "Andres Heilsberg" - tərəfindən Microsoft - da Java - ya Rəqib Olaraq İnkişaf Etdirilən , sadə müasir , ümumi məqsədlər üçün  yaradılmış, Obyekt Yönümlü Bir Programlama Dilidir.  C#, özündə  böyük əməliyyatlar ehtiva edən, özündə böyük məlumat daşıyan - ötürən, bir şirkətin virtual idarə edilməsi üçün lazım olan bir proqram(CRM) yazmaq üçün  hər şeyi özündə birləşdirən proqramlaşdırma dilidir. C# real dünya obyektlərini daha aydın şəkildə virtual aləmdə tətbiq etmək üçün ən səmərəli dillərdən biridir.C# multi paradiqmalı proqramlaşdırma dilidir.Özündə imperative,deklarativ,functional,generic,OOP paradiqmaları cəmləşdirir. İnkişaf etmiş bir xüsusiyyəti də odur ki, DEBUGGER ayarı ilə səhv ehtimalları aradan qaldırılır. Yazılı proqramdan sonra kompilyator tərəfindən təsbit edilən siniflər və sintaksis səhvləri proqramçı tərəfindən ayrı-ayrı ekranda göstərilir və proqramçı bu xəta pəncərəsindəki səhvləri aşkar edərək asanlıqla düzəldə bilər. C# - Microsoftun Java Uzərində Dəyişiklik Etməsini İstəmədiyi Ücün Yaradıldı. C# - İlk Yaradildigi Gündən Bəri Sürətli Bir Şəkildə Böyüdü və Hal-hazırda Dünyanın Ən Populyar Programlama Dillərindən Biridir. Microsoft Platformunda Program Təminatlari İnkişaf Etdirmək Üçün Dizayn Edilmiş Ümumi Məqsədli bir dildir ve Windows Üzərində İşləmək Üçün .NET Framework Tələb Edir.C# - in Yaradilmasinda C ve C++ - dan İstifade Edilib və Buna Gorədə C#  C və C++ - in Hibrididir. .NET Framework Bir Çox Programlama Dilini Dəstəkləsədə C# Sürətli Bir Şəkildə Ən Populyar OlanlardanBiri Halına Gəldi. C#  - Demək Olar ki  Hər Şey Yaratmaq Üçün İstifade Olunur ama Özəlliylə windows Masaüstü Program Teminatlari və Oyunlar Yazmaq Üçcün Daha Yaxşıdır. C# - Həmçinin Web-Tətbiqlər Yaratmaq Üçündə İstifade Olunur amma özəlliklə Mabil Tətbiqlər İnkişaf Etdirmək üçündə get-gede daha Populyar Hala Gəlmişdir.Xamarin Kimi Cross-Platform alətlər(tool-lar) C# - da Yazılan Tətbiqləri Demək Olar ki Bütün Mabil Cihazlar-da İstifadə Olunmasını Təmin Edir.

> C# - Günümüzdə Ən Papulyar Oyun Mühərriki olan Unity Oyun Mühərrikini İstifadə Edərək Oyunlar Yaratmaqı Təmin Edir. En Yaxşı Oyunların   3/1 - dən Çoxu Unity İlə Yaradıldı ve Unity Muhherikini İstifadəsi İlə Yaradılan Təqribən 770 milyon aktiv Oyun İstifadecisi Var. C# -   Bu Tətbiqləri Yaratmaq Üçün Populyar Bir Alətdir Programçı ve Programlamaya Yeni Başlayanlar Üçün-də Mükəmməl Bir Seçimdir.C# -         həmçinin Statik Olaraq Yazılmış Bir Dil-dir  və Bu Səbəblə Bir Təminata(exe) - Çevrilmədən Öncə Yoxlanilir. Bu Yeni Başlayanlar Üçün     Xüsusilə Praktik Ola Biləcəy Xətaları Tapmaqı Asanlaşdlrır. C# - Qarmaşıq Bir Dil-dir və Bu Dildə Master Olmaq Bəzi Sade Dillər         ilə(Pyton) Müqayisede Daha Çox Vaxt Alır. Bu O Demək-dir ki Programçının İrəli Səviyyəli Programlar Yazmaqi Üçün Daha Çox Kod           Öyrənməyi Lazımdır ve Bu Yeni Başlayanlar Üçün Sinir Bozucu Ola Bilər. Güclü Əsnək və Microsoft Tərəfindən Dəstəklənmiş Olması C# - ı   Movcud Olan Ən Yaxşı Programlama Dillərindən Biri Halına Gətirmişdir.Bu Gün C# - Ən Yaxşı Programlama Dilləri Arasında 4 - cü Sırada     Yer Alır ve Teqribi Developerlərin 31 faizi Bu Dili Müntəzəm Olaraq İsitfadə Edir. Həmçinin C# Stack-overflovda(Hansıki C# - ilə         Yaradıldi) 1.1 milyondan çox mövzu ilə 3-cü sırada yer alır. Bu Populyarlıq İnkişaf Etmiş İş Bazarına Çevrilir. Hər Ay 17000 - dən Çox   C# - işləri Elan Edilir və Ortalama 72000$ - dan çoc maaş - ilə. Sadəcə Birləşmiş Ştatlar-da Hər ay 92000$ - lıq Maaşla 6 mindən Çox     İş Elan Edilir.







2. C# - ın özəlliklərini İzah Edin? ( Suleyman )

  - Müasir proqramlaşdırma dilidir. C# müasir tələblər əsasında yaranıb.
  - Updatable.Avtomatik olaraq c# yeni versiyasi cixanda yenilenir,neticede kohne fayllar yenisiyle evez olunur.
  - Windovs ,Mac ve Linux - da işləyir
  - Windovs Müştəri Tətbiqləri ,Windovs Mağaza Tətbiqləri ,İOS Tətbiqləri,  Android Tətbiqləri və Həmçinin (backend  framevork           library) - lar Yaratmaq Üçün İstifade Olunur.
  - Fiks Etme, Yenidən Düzənləmək və Kod Yaratmaq Alətləri(cw+tab+tab)dəstəkləyir.
  - Gəncdir ve inkişaf edir.
  - Obyekt Yönümlüdür(OOP dildir).Yeni ki ,biz c#-da hər şeyi obyekt kimi goruruk,obyektler klasslarin ekzemplarıdır,klasslar isə inheritance iyerarxiyasi yaradırlar
  - Sadədir-yəni həm  yazılma sintaksisi insan dilinə daha  yaxın olduğu üçün hamı tərəfindən də başadüşüləndir, həm də obyekt yönümlü olduğu üçün real həyatdan olan istənilən bir prosesə uyğunlaşdırmaq mümkündür.
  - Strukturlu programlaşdırma dilidir.
  - Type safe(güvənli yazı)
  - Birliktə Calisabilirlik(Interoperability)

3. C#-ın üstünlüklərindən ən vaciblərini sadalayın. ( Sekine )

Səkinə tərəfindən:
  - Type-safe olması;
  - Obyekt yönümlü olması;
  - .Net platforması altında işləməsi;
  - Hər növ tətbiq yaza bilmə bacarığı;
  - C# dilində yazılan programları .Net platforması altında digər dillərdə istifadə edə bilmə.
  
  
4. What are IDE’s provided by Microsoft for C# development?

> Visual Studio 2017

5. C# - daki Kamentariya Tiplərini İzah Edin

> c#-da Kamentariyalar Bizə Kod Hissəciylərini Başa Düçməyimizə Kömək Edir. Kamentariyalar Compiler Terefinden Tamamən Yox Sayilir

> C#-da 3 Kamentariya Tipi Vardırş

>1.Single Line Comments(Tək Sətir Kamentlər)
 2.Multi Line Coments(Çox Sətirli Kamentlər)
 3.XML Comments(XML Kamentlər)

 > 1) Tək Sətirlər Kamentlər Cüt Slaş ilə Başlayır , Compiler " // " - dan Sonra Sətirin Altina Düçənə Qədər Yazilan Hər Şeyi Yox Sayır 
   
       int a = 5  // 5 və 7 - ni Toplayır
   
> Tək Sətirli Kamentariyalar Ayrı Bir Sətirdə və ya Kodlarla Eyni Sətirdə Yazıla Bilər  Ama Ayrı Bir Sətirdə Yazmaq Daha Yaxşıdır.
   

 > 2) Cox Sətirli Kamnentariyalar " /* " - ilə Başlayır və  " *\ " Bitir. Çox Sətirli Kamentariyalar Birdən Çox Sətirə Yayıla Bilər.


  > 3)XML - Bilmirəm Hələki

  > Kamentariyalar Kod Hissəciklərini izah Etmək Üçün İstifade Olunur Ama Çox İstifade Etmək Olmaz

 > 1)Kamentariyalar Qarışıq Algoritmaları İzah Etmək Üçün İstifade Edilməsi Daha Düzgündür.
 > 2)Kamentariyalar Uzun Bir açıqlama Yerinə qısa və kankret olmalıdır.

   

6. C# - daki Sealed Klasını İzah Edin?

> Sealed Klass Obyekt Yönümlü Programlamanın İnheritance(miras) Xüsusiyyətini Ləğv Edir. Sealed Klasin İxtira Olunmasinin Səbəbi Odur ki Həmin Klasin Genişləndirilməyə Ehtiyyacinın Olmadığını deyirikk. Bu Klass İnheritance Ala Bilməz. C# - da "sealed" keywordu Klasın Sealed Klas Olduğunu Müəyyən Edir. Əgər Sealed Tətin Olunmuş Klas-dan İnheritance Almaqa Cehd Etsək Compile Error Verəcək.

7. Give an example of using sealed class in C#?
" Sealed " class OOP nin miras xüsusiyyətlərini məhdudlaşdırmaq üçün istifadə olunur. Hər hansı bir class "sealed" keyvordu ilə bəyan edildikdə miras alına bilmir. "sealed" eyni zamanda həm atributlara həm də method lara təyin oluna bilsə də "sealed" keyvord unun bu xüsusiyyəti onlara aid edilmir. Sadəcə class üzrə təyin oluna bilir. 2 misalla visualda izah edəcəm

8. List out the differences between Array and ArrayList in C#?
> hər 2sinin oxşarlıqı ondan ibarətdir ki, 1 dən çox datanı saxlamaq üçün istifadə olunur.
Array lərin Listlərdən başlıca xüsusiyyəti ondan ibarətdir ki, array lər sabit elementləri saxlamaq üçündür. List lərdə isə datanın sayı avtomatik təyin olunduğundan başda sayı bildirmək lazım deyil. 
Bir array təyin etdikdən sonra onun elementlərini artırmaq olmur. List lərə isə sonradan istənilən sayda element artırmaq mümkündür.
Bir array təyin edilərkən ancaq təyin edildiyi tipin elementlərini daşıya bilir. Listlərdə isə istənilən növ tipin elementlərini saxlamaq mümkündür.
Bir Array yalanız " using System; " namespace ilə istfadə edildiyi halda ArrayList " using System.Collections; " namespace ilə istfadə edilir.  Sources of literature : "https://msdn.microsoft.com/en-us/library/system.collections.arraylist(v=vs.110).aspx" ; "https://www.c-sharpcorner.com/blogs/difference-between-array-and-arraylist-in-c-sharp" ; "http://www.tutorialsteacher.com/articles/difference-between-array-and-arraylist-in-csharp" ;

9. C# da "using" nə üçün istifadə olunur
> "using" keyvordunun 2 istifadə yeri var :
Directive kimi :
C#  da "using" keyvord u fərqli namespace lərin müxtəlif classlarını və methodlarını istifadə etmək üçün istifadə olunur.
Statement kimi :

> "using" - keywordu istifade etdiyiniz siniflərdə avtomatik olaraq dispose() metodunu işə salır. Yəni işimiz Bitdikdən sonra ObjectName.Dispose() yazmaq lazım deyil. "using" - bunu bizim Yerimizə eliyir.(bu temanı başa düşmək üçün dispose() metodunu bilmək lazımdır sual - 14 - e bax)

    using(işlənəcəy kodlar)
    {
      Burda yazılan kodlar avtomatik olaraq Dispose() - əməliyyatına məruz qalır. 
      Burda yazılan kodların ömrü burda bitir.
    }


 
10. Explain namespaces in C#?
> "namespace" keyvvord u c# da 2cür istifadə ediə bili :
1cisi : Öz lahiyələrimizi yazan zaman çoxlu class istifdə etdiyimiz zaman.
Buç class ların idarə edilmsi və onların başqa namespace lərdə istifadəsini asanlaşdırır
2cisi : Öz lahiyələrimizdə c#  tərəfindən yazılmış hazır class ların methodlarını istifadə etmək üçün. Məsələn müəyyən bir nəticəni ekrana çixartmaq üçün istifadə olunan Console class ının methodu olan WritLine() method unu istifadə edə bilmirik. Bu zaman CİL(Common İntermadiete Language) ikinci adı ilə .Net platformu System class ından istifadə edir: System.Console.WritLine(); bunun qarşısını almaq üçün, ümumiyyətlə c# da bunun kimi müxtəlif methodları sərbəst istifadəsini asanlaşdırmaq üçün "namespace" keyvord undan istifadə edilir.

11. Why to use keyword “const” in C#? Give an example.
<<<<<<< HEAD

> Fərz edək ki Bir dəyişənimiz var  və biz bu dəyişənimizin dəyərinin heç bir yerdə dəyişilməməsini sabit qalmasını istəyə bilərik.Bu     zaman Bize (const) - keyvordu komək edir. Const keyvordunun Qaydaları.
> 1. Const keyüordu local Dəyişənlərə və Filed-lərə Təyin Edilə Bilər.
> 2. Const keyüordu yalnız primitiv dəyərlərə təyin edilə bilər(int double).
> 3. Constant təyin etdiyimiz (field ve dəyişənlərə) declaration anında dəyər təyin etməliyik.
> 4. Constant dəyişənlər (const) - keyüordu ilə təyin edilir.
=======
>"const" keyword u bir class daxilində və ya bir proq da sabit qalacaq dəyişənləri declare etmək üçün istifadə olunur. Adi dəyişəndən fərqi ondan ibarətdir ki, onu dəyər vermədən bəyan etdiyimiz halda "const" la bəyan etdiyimiz bir dəyişənə mütləq sürətdə bir dəyər assign etməliyik əksi halda səhv yaranacaq. Bütün numeric data type larla, o cümlədən Bool tipi ile, string lərlə, null tipi ilə işlənə bilir. Class daxilində ancaq atributlara təyin oluna bilir. Method lara təyin oluna bilməz. Static keyword u ilə təyin edilə bilməz. Onsuz da "const" özü static xüsusiyyəti daşıyır. Çünki adi class da olan adi və "const"la olan property yə fərqli cür müraciət olunur. Adi property yə class dan yaranmış obyektlə, "const"la olan property yə class vasitəsilə müraciət etmək mümkündür. Məs : Visual a baxın.
 Amma "const" istifadəsində bir şeyoi nəzərə almaq lazımdır ki, proqram daxilində uzun zaman sonra dəyişəcək dataları "const" la vermək düzgün deyil. Məs: məhsulun növünü, qiymətini hətta şirkətin şüar və şirkəti digərlərindən fərqləndirən xüsusiyyətləri belə const la vermək düzgün deyil. Bir const dəyəri verən zaman sonradan onu override etmek olmur.
>>>>>>> 51f3de6cdc71219301ef12fcb23861bc29fb79cd

12. What is the difference between “constant” and “readonly” variables in C#?
> "readonly" keyword u const kimi yenə sabit dəyərlər yaratmaq üçün istifadə olunur. Fərqi ondan ibarətdir ki, const un sonradan dəyərini dəyişdirmək olmursa, "readonly" nin dəyərini dəyişdirmək mümkündür. Ancaq class daxilində bəyan edilə bilir. Const la bəyan edilən bir dəyərə ancaq class la müraciət etmək mümkündürsə readonly ilə bir property yə obyekt vasitəsilə müraciət etmək olur. Readonly nin dəyərini sonradan dəyişdirmək mümkündür, ancaq bu const da olmur.

13 C# -da “static” açar sözünü izah edin ?
14. What is the difference between “dispose” and “finalize” variables in C#?
15. How the exception handling is done in C#?
> C# da  exeption problemi yazılan kodda səhv yaranan zaman meydana çıxır və proq. ın cash olmasına səbəb olur. Bunu aradan qaldırmağın 3 üsulu var:
Try - catch();
Try - finally();
Try - throw()

16. Can we execute multiple catch blocks in C#?
> Bir namespace error problemlərini həll etmək üçün 1dən çox catch methodu əlavə etmək mümkündür. Hər bir exception methodu System.Exception class ından inheritance aldığına görə bu class dan ancaq 1 catch almaq olur. 1dən çox catch  istifadə etmək üçün başqa bqaşqa namespace ləri istifadə etmək lazimdir. Ancaq onlardan yalnız biri işləyəcək
misal olaraq Visualda kod seklinde yazmisam : ...

17. Why to use “finally” block in C#?
> Əgər yazılan kodun səhv olması ehtimalı yüksəkdirsə, həmin hissə try blokunun içində yazılır catch metodu isə o səhvi tutur ekrana çıxartmır və dolayısı ilə prog crash olunmasının da qarşısını alır əvəzinə biz istədiyimiz nəticəni çıxardır. Amma bunun bir "finally"  keyvordu da var ki, catch metodunun əvəzinə proq crash olunsa belə ekrana fəqrli nəticə çıxardır. Məs: mən 2 fərqli tipdən olan dəyərlərdən birini digərinə çevirən zaman ortaya çıxan problemi finally ilə verməyə çalışacam Visualda kod şəklində yazmışam : ...

18. What is the difference between “finalize” and “finally” methods in C#?
19. What is the difference between “throw ex” and “throw” methods in C#?
20. Can we have only “try” block without “catch” block in C#?
 > Try ifadəsini catch olmadan finally ifadəsi ilə vermək mümkündürş Ancaq tək işlənməsi mümkün deyil. Çünki try kodda səhv olan hissəni bildirir. Bu səhv olan hissəni tutub saxlamaq lazimdir proq. crash olmasın. Bunu da catch olmadan finally vasitəsilə vermək mümkündür.

21. List out two different types of errors in C#?
> 3cür error tipi var :
Syntax Error;
Run-Time Errors;
Logical Errors;
Bunlardan 1cisi sadə və ən çox edilən error lardandır. Bu errorlar proq. dillərindən asılı olaraq dəyişir. C# dili visual studioda yazildiğindan bu İDE bize avtomatik xətanı bildirir. məs: yazilan kod sətrinin axırında ; işarəsini qoymamaq, string tipində bir dəyişən təyin edib dəyərini int lə vermək və.s
Run-time error ları proqramda heç bir sintaks erroru olmasa belə prog. işləyən zaman meydana çıxan səhvlərdir. Məs : int tipində bir dəyişən təyin edib onu 0 - a bölüb ekranda göstərmək istəsək prog. crash olacaq
Logical errorları o deməydiki prog. tam işliyir amma istifadəçiyə təqdim edilmiş proqramda istifadəçinin daxil etdiyi yalnış dəyərlər üzündn meydana çıxan errorlar. Məs: istifadəçi yaşını hesablamaq üçün - ədəd daxil edirsə və ya rəqəm əvəzinə yazı, simvol daxil edirsə, proq işləməyəcək
22. Do we get error while executing “finally” block in C#?
23. Mention the assembly name where System namespace lies in C#?
> System namespace nin c# da yeri - mscorlib.dll
24. What are the differences between static, public and void in C#?
> static keyword u class dan asılı olmayaraq bir dəyişəni, property ni və ya bir metodu namespace daxilinde istənilən yerdə istifadə etmək üçün istifadə olunur. Static lə bir class ı da bəyan etmək mümkündür. Bu zaman class ın bütün property və metodları da static olacaq. Bu class ın metod və peoperty lərinə müraciət etmək üçün obyekt yaratmaq lazım deyil, birbaşa class dan müraciət etmək mümkündür. Məs : Visual da nümunə vermişəm

25. What is the difference between “out” and “ref” parameters in C#?
> Out və Ref metodları müəyyən bir dəyişənin dəyərini jər hansı bir metodun içinə parametr kimi ötürərək dəyişdirilməsidir. Bunlar arasında yeganə fərq ondan ibarətdir ki, out metoduna parametr kimi ötürəcəyimiz dəişənə əvvəlcədən dəyər assign etməyə ehtiyyac yoxdur, amma ref metoduna parametr kimi ötürəcəyimiz dəyişənə mütləq dəyər təyin etməliyik. Allaha and olsun ki, kurs başlayannan bəri indi başa düşdüm buların fərqin. Visual da kod şəklində vermişəm

26. Explain Jagged Arrays in C#?
> Array lər dedik ki, məlum bir data type ın sabit dəyərlərini saxlamaq üçün bir qabdır. Amma  array lər arasında elə bir array növü var ki, onun elementlərinə də ayrı ayrılıqda array təyin edə bilir ki, onun da adına jagged array deyilir. Adi array dən fərqi yoxdur. Təyin olunma qaydası belədir :         " [][] ". Visual da kod şəklində misallar vermişəm

27. Can we use “this” inside a static method in C#?
> This keyword ü hər hansı bir klasdan yaranan obyektə işarə edir. Static keyword ü isə class member sayılmayıb hər hansı bir namespace səviyyəsində əlçatılan hər hansı bir dəyişəni, metodu, property ni işarə edir. Əgər class daxilində təyin olunubsa, bir başa class dan müraciət olunur. Class ın static olmayan property və ya metodunu static metodun içinə ötürməyi  2 üsulu var. Visualda verdiyim misalda ForThis() mənə ForThisİnStaticMethod() class ı tipində bir obyekt qaytaracaq, sonra isə ForStatic() metodu da bizə yenə də ForThisİnStaticMethod() klası tipində bir obyekt qaytaracaq.

28. What are value types in C#? C#-da deyer tipleri nedir ne demekdir? 
30. What are reference types in C#?
31. Can we override private virtual method in C#?
> protected internal access modifier in əsas məğzi ondan ibarətdir ki, bu modifikatorla təyin olunmuş istənilən metod və ya property ni ancaq miras alındığı class istifadə edə bilər. İnsan üzərindən danışsaq belə deyə bilərəm ki, Babanın bu xüsusiyyətini ancaq ata daşıya bilər, sonradan nəvə və başqaları bu xüsusiyyəti daşıya biməzlər
32. Explain access modifier – “protected internal” in C#?
33. In try block if we add return statement whether finally block is executed in C#?
34. What you mean by inner exception in C#?
35. C# da String Builder klasın izah edin.
36. What is the difference between “StringBuilder” and “String” in C#?
37. What is the difference between methods – “System.Array.Clone()” and “System.Array.CopyTo()” in C#?
38. Can you store multiple data types in an array?
39. How we can sort the array elements in descending order in C#?
40. Explain circular reference in C#?
41. List out some of the exceptions in C#?
42. Explain Generics in C#?

 > 

43. Explain object pool in C#?
44. What you mean by delegate in C#?

<CavCav

 > C# - da "delegat" - lar  "c və c++" - dakı "pointers function" - lara bənzəyir. "delegate" hansısa bir metoda baş vuran referans tip dəyişəndir(burda ne dedim ozumde bilmedim).Delegat-lar xüsusi ilə "event və call-back" metodları tətbiq etmək üçün istifadə olunur.Bütün "delegate"-lar "System.Delegate" - sinifindən "derive"(əmələ gəlirlər) - olunurlar. Delegate-lər yalnız özü ilə "eyni xüsusiyyətlərə" sahib olan metodlara baş vura bilərlər. Məsələn 
 
    public delegate int MyDelegate(string s)
    
>Yuxardaki Delegatemiz "string parametreli  və int return(dönüş) tipi olan" hər bir metoda referans(baş vura bilər) - ede bilər.Delegate-lər "delegate" - keyüordu vasitəsi ilə təyin olunurlar.Delegate - nin Sintaksisi Belədir.

    <lazım olan yerdə access modifieri yazmaq olar> delegate <return tipi> <delegate-nin adı> <istəyə bağlı olaraq delegate-nin parameteri>
    
    public delegate string FirstDelegate(istəyə bagli olaraq)

>Delegate - başlatmaq(initalize) - bir "delegate" - təyin olunduqdan sonra təyin olunan delegatinin obyekti(instance) "new" - keywordu - ilə yaradılmalıdı və spesifik(müəyyən) metod ilə bağlantılı(əlaqəli) olmalıdır.


>Delegate-lər mövzusu üçün əlavə-lər - Delegate .NET - in təməl(base) struktur-larından biridir. "Delegate"  delegate-lər yaratmaq üçün istifadə olunan bir sinifdir bütün delegate-lər bu sinfdən yaranırlar. Delegtae-nin xüsusiyyətləri ilə uyğunlaşan hər bir metod hansıki "delegate" - ilə  "eyni return" - tipi və parametrlərdən ibarətdir bu metodlar delegate ilə işlənə bilərlər.

>Delegate Tipləri

>1.Singlecast Delegate
>2.Multicast Delegate

>"delegate" - in bir sinif olduğunu demişdik. Hər bir "delegate" təyin edildiyi anda .NET "class library" - nin təməl(base) "delegate" sinifindən miras alır. Bu sinif "System.Delegate" və ya "SystemşMultiCastDelegate" - siniflərindən biri ola bilər.

>Single Cast - "delegate" - lər bir dəfədə yalnız "tək" bir metoda baş vurur(referans). Bu tip Delegate-lər "System.Delegate" - sinifindən "derive"(əmələ gəlir) olunurlar.

>Multi Cast - "delegate" - lər birdən çox metod ilə təmin olundugları halda bu(birdən çox metoda referans etdiklərində bu) "delegate" - lər "Multi-Cast"
-delegate -lər olaraq  bilinirlər və "System.MultiCastDelegate" - sinifindən "derive"(əmələ gəlir) olunurlar.

 Delegate-dən obyekt yaratmaq(initialzie etmek)
    
    public delegate void DelegateExample();
    
    DelegateExample d1 = new DelegateExample();

   
45. What are the types of delegates in C#?
 
 <CavCav
 
 >Single Cast
 >Multi Cast
 
46. What are the three types of Generic delegates in C#?
47. What are the differences between events and delegates in C#?
48. Can we use delegates for asynchronous method calls in C#?
49. What are the uses of delegates in C#?
50. What is Nullable Types in C#?

<CavCav

 >C# - da "Dəyər(value)" - tiplərinə "null" - dəyər ata bilmərik. Məsələn
   
    int i = "null";
    
>Yuxardakı təyinat bizə "error" - verəcək "compile time error".

>C# 2.0 bizə "nullable" - tiplər təqdim edir. Bu "nullable" tiplər "null" - dəyərini "dəyər(value)" - tiplərə təyin etməyimizə icazə verir. "nullable" - tipləri Nullable<T>(T - burada tip demekdir). Məsələn
 
    Nullable<int>a = null;

>"Null" - tipindən biri ç təməl dəyər tipi üçün düzgün dəyər aralığını və boş bir dəyər göstərə bilər.(demək istəyir ki nullable təyin olunan dəyər həm null tipində həmdə öz custom tipi nədisə o tipdə dəyər götürə bilər).Nullable tiplər "System.Nullable<T>"  "structun" - nun obyektidir(instance)(örnəyidir). Nullable dəyər təyinatı üçün qısa yol.
 
    Nullable<T>a = 5; bunun qısa yolu
    int? a = 5;



> Bəzən təyin olunan dəyişənə nə dəyər mənimsədəcəyimizi bilmiriksə və ya sonradan mənimsədəcəyiksə "null" dəyərindən istifadə edirik. Reference type dəyişənlərdə bu problem yaratmır, lakin value typelarda bunu etmək üçün ? işarəsindən istifadə olunur və null dəyəri ötürə bilirik. 
51. Why to use “Nullable Coalescing Operator” (??) in C#?

> "null coalescing" əməliyyatı "??" 2 sual işarəsi istifadə edərək "null" dəyəri saxlayan dəyişənə "custom" dəyər təyin etmək üçün istifadə "cool" bir yoldur. Məsələn


    string message = null;
    string result = message ?? "Hi";
    Console.WriteLine(result);//"Hi"
  
>"message" - dəyişəninin dəyəri "null" olduğu üçün  onun dəyərini "Hello" - ilə dəyişə bilirik.

>Amma dəyişənin dəyəri "null" - dəyəri olmazsa "null coalescing" - əməliyyatının yerinə yetirilməsinə baxmayaraq  dəyişənin dəyəri nədirsə o göstəriləcək. Məsələn

    string message = "Hello";
    string result = messsage ??  "Hi";
     Console.WriteLine(result); //"Hello"
    
Yuxardaki Nümunede "message" string dəyər saxladıgı üçün(null saxlamadığı üçün) Dəyişənin öz dəyəri göstəriləcəkdir.   

52. What is the difference between “as” and “is” operators in C#?
53. What is the difference between CType and Directcast in C#?
54. Is C# code is unmanaged or managed code?
55. Why to use lock statement in C#?
56. Explain Hashtable in C#?
57. How to check whether hash table contains specific key in C#?
58. What is enum in C#?
59. Which are the loop types available in C#?
> C#-da mümkün dövr növləri: "for", "foreach", "while" və "while do". 
60. What is the difference between “continue” and “break” statements in C#?
61. Write a sample code to write the contents to text file in C#?
62. What you mean by boxing and unboxing in C#?
63. Explain Partial Class in C#?

> Partial Sinif Qavramı C# 2.0  və Visual Studio 2005 - ilə gələn özəllikdir. Partial Sinif Qavramı .NET Framevork - un 2.0 verisyaında   Dəstəklənir. Əgər İşlətdiyiniz Versiya 1.0 və ya 1.1 - dirsə Partial Sinif Qavramı İşləməyə Bilər.

> Böyük Lahiyələr Üzərində İşlədəyimiz Zaman Sinif-ıər zamanla oxunması çətin hala gələbiləcək kod sətirləeri ilə dolur. Partial Sinif     Bizə Bir Sinifi birdən çox sinifı(hissəyə) bölməyimizə icazə verir. Partial Sinifi qurucuları filedları metodlaı ayrı-ayrı               yaratmaqımızı təmin edir. Fiziki Olaraq birdən çox parça ilə yaranan partial siniflərç işləmə anında tək bir sinif olaraq bütün         elementləri içərisində birləşdirir. Partial sinif ilə fiziki olaraq parça siniflərin birləşə bilməsi üçün sinif adları eyni             olmalıdır.İndi İsə bir sinifin içərisində olan (quruculari fieldlri metodları) partial sinif ilə yazaq və birləşmiş halını görək.

    public partial class PersonPartial  
    {  
        public PersonPartial()  
        {  

        }  
  
        public PersonPartial(PersonPartial person)  
        {  
            PersonelEkle(personel);  
        }  
   } 
   
   
    public partial class PersonPartial  
    {  
       private string name;  
       private string surname;  
       private int age;  
       private List<PersonPartial> persons = new List<PersonPartial>();  
    }  
    
    
    
       public partial class PersonPartial  
       {  
          public string Name  
          {  
              get { return name; }  
              set { adi = value; }  
          }  
  
          public string SurName  
          {  
              get { return surname; }  
              set { soyadi = value; }  
          }  
  
          public int Age  
          {  
              get { return age; }  
              set { yas = value; }  
          }  
  
          public List<PersonPartial> Persons  
          {  
              get  
              {  
                  return persons;  
              }  
          }  
  
          public PersonPartial personalSave  
          {  
              set   
              {  
                  persons.Add(value);  
              }  
          }  
     }
     
          public partial class Personeller  
          {  
              public void PersonelEkle(Personeller pers)  
              {  
                  PersonelKayit = pers;  
              }  
          }
          
          
          
          static void Main(string[] args)
        {
            Person pers = new Person();
            pers.Name = "Cavidan";
            pers.SurName = "Akberov";
            pers.Age = 17;
            pers.AddPerson(pers);
            Person personSave;
            Console.WriteLine(pers.Name);
            
        }
 

> Gördüyünüz kimi (main) metodun-da çağırdığımızda 4 parçadan yaranan Sinifimiz Çağırılma anında tək parça olaraq                         görüntülənəcktir.Partial Sinifi Qarmaşıq Siniflər-də Olduqca İstifade Olunandır. Qarmaşıq Siniflərdə Olan kodları partial sinifi ilə     ayıra bilərik və bu bizə koda daha çox hakim olmağımıza kömək edəcək.

64. Explain Anonymous type in C#?
65. Name the compiler of C#?
66. Explain the types of unit test cases?
67. Explain Copy constructor in C#?
68. Explain Static constructor in C#?
69. Which string method is used for concatenation of two strings in c#?
70. Explain Indexers in C#?
71. What are the collection types can be used in C#?
72. Explain Attributes in C#?
73. List out the pre defined attributes in C#?
74. What is Thread in C#?
75. List out the states of a thread in C#?
76. Explain the methods and properties of Thread class in C#?
77. What is a class ?
78. What is an Object?
79. What are the Access Modifiers in C# ?
80. Explain Static Members in C# ?
81. What is Reference Type in C# ?
82. Define Property in C# ?
83. Explain Overloading in C# ?
84. What is Constructor Overloading in C# .net ?
85. What is Function Overloading in C# .net ?
86. What is Operator Overloading in C# .net ?
87. What is Data Encapsulation ?
88. Explain Inheritance in C# ?
89. Can Multiple Inheritance implemented in C# ?
90. What is Polymorphism in C# ?
91. Explain the use of Virtual Keyword in C# ?
92. What is overriding in c# ?

> Override miras yolu ilə təməl sinifin referansını istifadə edərək fərqli siniflərə aid metodları çağırmağımıza icazə verən bir xüsusiyyətdir.C# - bizə (override) əməliyyatını həyata keçirmək üçün 2 keyüord verir. (virtual və override).
Bir Metod yalnız (virtual) keyvordu ilə təyin olundugu halda biz miras alınmış sinifdə onu (override) - edə bilərik.(override) base clasda olan virtual metodu (override) - edir. Override Ozəlliyi Programçılara Təməl Sinifdə (virtual) memberi miras almış sinifdə yenidən tətbiq etməyə icazə verir. Override miras alan sinifdə dəyişilməyə ehtiyyacı olan (metod property indexer və ya event) - lər ilə işlənə bilər. override xüsusiyyəti C# - da polymoprhism qavramını tətbiq etmək üçün dizayn edilmişdir.

93. What is Method Hiding in C# 

> Derived Sinif İçərisində təməl(base) Sinifə aid bir metodu (override) etmeden təkrar Tanimlasanız base(temel) sinifdəki halı qorunacaqdır. Bu Hala Metod Hiding Deyilir.

    class Product

    {

        public int İd { get; set; }

        public string Name { get; set; }

 

        public void Test()

        {

            Console.WriteLine("Product Sinifinin Memberiyəm");

        }

    }
    
    
    
    
    class Book : Product

    {

        public string Author { get; set; }

 

        public void Test()

        {

            Console.WriteLine("Kitab Sinfinin Memberiyəm");

        }

    }


> Burada Book Sinifinde Olan Test() Metodu  Temel Product Sinifinde Olan Test() Metodu İle Eynidir Buna Gore  Base Sinifdə Olan Test()     Metodu  Gizlenir ve Book - da Olan Metod İşləyir ama Compiler Bizə Xeberdarlıq Verir. Buna Görədə Metod hiding Eederek Bu xeberdarlıqı   Aradan Qaldırırıq. nev keyvordu istifade ederek yoxlayaq.
 
      
    class Book : Product

    {

        public string Author { get; set; }

 

        //new public void Test() şeklinde de yazabiliriz.

        public new void Test()

        {

            Console.WriteLine("Kitab Sinifinin Memberiyem");

        }

    }
    
Bele Daha Düzgündür Artıq Base(təməl) Sinifdəki Metod Gizləndi. 

94. What is Abstract Class in C#?

> Abstract Siniflər .NET Tərəfindən təmin edilən təməl davranışlardan biridir. Ümumi olaraq yalnız təməl Sinifləri təmsil edən və hər hansı birinin bu Siniflərdən Obyekt yaratmasını istəmədiyimiz siniflər yaratmaq istəyə bilərsiz. c# - da (abstract) istifade ederek Astract Sinifləri Tətbiq edə Bilərik. Abstrackt sinifin mənası bu sinif - də obyekt yaradıla bilməz ama miras alına bilər.

    abstract class absClass
    {
     
    }

> Abstract Sinif (abstract) olan və (abstract) olmayan metodlar saxlaya bilər. Abstract memberlərin (abstract) sinif içərisində heç bir tətbiqi olmur ama ondan miras alan sinifə bu özəlli təmin edilir.


         abstract class absClass
         {
             public abstract void absMethod();
         }

> Dediyimiz kimi Abstract Siniflərin İçərisində abstract olmayan memberlər - də ola bilər.

    public void Show()
    {
       
    }

> Abstract metod və Abstract Sinif-dən başqa heç bir yerdə təyin edilə bilməzlər. Abstract metodlar derive olundğu sinif-də (override) olunmalıdırlar. Abstract metodların (body) - si Olmur.

> Abstract- da Bəzi Qaydalar

> 1.Abstract Sinif (selaed) - olaraq təyin edilə bilməz
> 2.Abstract metodlar yalnız abstract sinifdə ola bilər
> 3. Abstract metodlar private ola bilməz
> 4.Abstract Sinifin (Access Modifieri) həm Abstract Sinifdə həmdə ondan miras almış sinifdədə eyni olmalıdır
> 5.Abstract metodun (virtual) keyvordu olmur. Çünki Abstract metod onsuzda virtual olur.

95. What is Sealed Classes in c# ?

> Sealed Siniflər Obyekt Yönümlü Programlaşdırmanın inheritance(miras) xüsusiyyətini ləğv eiliyir. Sealed Sinifinin İxtira olunmasının məqsədi odur ki biz bu sinifə deyirkki sənin genişləndirlməyə Ehtiyyacın Yoxdur. Sən miras ala Bilməzsən

96. What is an Interface in C# ?
97. What is a Constructor in C# ?

> Qurucular Xüsusi Metodlardır və Sinifdən örnəy(abyekt) yaratdıgımız anda işə düşürlər.Qurucuların Əsas Məqsədi Sinifin Örnəyi Yaranan Anda Sinifdə Olan (private) gizli field-lari Başlatmaqdır. Əgər Biz Özümüz Qurucu Metod Yazmasaq (Compiler) Avtomatik Olaraq Default Qurucu Metodu İşə Salacaq. Default(varsayılan) qurucular Sinfidəki (numerik) field-lərə  zero(0) (string və object) - filed-lərə isə (null) - dəyəri Təyin Edir.  Qurucularda Bəzi Vacib Nöqtələr Vardır.

> 1.Sinifin Birdən Çox Qurucu Metodu Ola Bilər
> 2.Bir Qurucu Metodun Hansısa (return) Tipi Yoxdur (void) - də Daxil Olmaqla. Çünkü Obyekt return Edir.
> 3.Statik Qurucular Parameter Qəbul Edə Bilməzlər.
> 4.Bir Sinif İçərisində Yalnız Bir Statik Qurucu Ola Bilər.

> Qurucular 5 Tipə Bölünür.

> 1.Default(varsayılan) Qurucular
> 2.Parametreli Qurucular
> 3.Copy Qurucular
> 4.Statik Qurucular
> 5.Private Qurucular

> 1.1)Hər Hansı Bir Parametresi Olmayan Qurucular varsayılan(defult) qurucular adlanır.bu cür qurucuların parametresi olmur.Bunun mənfi cəhəti odur ki default(varsayılan) qurucu hər obyekt yarananda eyni dəyərlər Təyin Edir.
Hər Obyekt Yaradanda Ferqli Deyerler Teyin Etmek Mümkün Deyil. Varsayılan Qurucu Aşagıdakı Dəyərləri Təyin Edir

 1.Bütün Numerik Filedlər-ə (0) - ı
 2.Bütün (string ve object) dəyərlərə (null) - u
 
> 2.2)Ən az Bir Parametresi Olan Qurucuya Parametreli Qurucu Deyilir. Parametreli Qurucunun Müsbət Cəhəti Odur ki Hər obyekt yaradanda fərqli dəyərlər Təyin Ede Bilərsiz.

    public class Employee 
    {
       public int a,b;
       
       public Employee(int x , int y)
       {
         this.a = x;
         this.b = y;
       }
    }
    
> 3.3)Başqa bir obyektden dəyişənləri kopyalayaraq bir obyekt yaradan qurucuya (copy) qurucu deyilir.(Copy) qurucunun Əsas Məqsədi         Mövcud Olan Obektin Dəyərləri ilə Yeni Obyekt Yaratmaqdır.  
  
  > 1.Statik Qurucuların Parameteri və Access Modifieri Olmur
  > 2.Statik qurucu işə düşdüyündə istifadeci onu idarə edə bilməz
  
  
  
  

   
     public class Employee 
     {
          public string Name
          public int Age

          public Employee(Employee emp)
          {
            this.Name = emp.Name;
            this.Age = emp.Age;
          }
    }
    
    
> 4.4)Qurucu Statik olaraq təyin olunarsa  Bütün Obyektlər Üçün Bir dəfə Çağırılır və Sinifin ilk Obyekti Yaradilan Anda işə düşür         Statik Bir Qurucu Sinifin Statik Olan Üzvlərini Başlatmaq və Sadəcə Bir dəfə run olunacaq kodu İşə salmaq üçün İstifade Olunur.

98. What is a Destructor in C# ? 
 
  >Destructor(yıxıcı metodlar) Constructor(qurucu metodlar) - ın tam tersidir. Referans Tipli Dəyişənlər Heap Üzərində Yaradılırlar və      Yaradıldıqca RAM - da yer tutrlar buda yaddaşa təsir edir. Yeni Obyektlərən Yaradılması Üçün Heap Sahəsinin Təmizlənməsi Lazımdır.      Yaradılan Bir Obyektin Heap - dan Silinmesinden əvvəl işə düşən metodlar-a destructor(yıxıcı) metodlar deyilir. .NET Framevork          işərisindı GC(Grabge Collector) Heap-da Olan Ancaq Referans Edilməyən Obyektləri artıq bu obyekt istifade olunmur deye fikirləşir və    heap-dan silir. Bu Əməliyyat belə Yerinə Yetirilir. GC(Garbage Collector) - un Bir Siyahısı var və GC() bu siyahıda refernası olmayan    obyektləri tapır və silir. Ama Biz GC(Garbage Collector)-un Bu Prosesi nə vaxt yerinə yetirdiyini bilmirik. Hətta Bəzən GC(Garbage      Collector) - işə düşmədən Program Bağlana Bilər və Referansı Olmayan Obyektlər Heap Üzərində Qalacaq. Tamda burda destructor()          köməyimizə çatır. Ama Bu Metod Çoxda İşlənən metod deyil. Bəzi irəli səviyyəli şərtlər tələb edir(hər ağzına gələn yerə destructor()    atma demək istiyrəm). İlk öncə destructor() metodların təyin edilmsinə baxaq.
  
    ~sinif-adı() {

     }
     
> Sintaks Cəhətdən constructor(qurucu metodlara) oxşayırlar ama hər hansı bir Access Modifieri və return(geri dönüş) dəyəri olmur.         Başında isə (~) işarəsi olur.    

99. What is CLR in c# ?

> Bu Mövzu genişdi sabaha hell edib edit eliyərəm

100. What is Garbage Collecter in C#?

> .NET Framevork          işərisindı GC(Grabge Collector) Heap-da Olan Ancaq Referans Edilməyən Obyektləri artıq bu obyekt istifade olunmur deye fikirləşir və    heap-dan silir. Bu Əməliyyat belə Yerinə Yetirilir. GC(Garbage Collector) - un Bir Siyahısı var və GC() bu siyahıda refernası olmayan    obyektləri tapır və silir.
